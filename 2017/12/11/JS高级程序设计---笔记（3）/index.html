<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JS高级程序设计---笔记（3） | 这就是个木匣子</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">这就是个木匣子</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">首页</a><a href="/archives" class="sidebar-nav-item">归档</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>JS高级程序设计---笔记（3）</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2017-12-11</div></div></div><article><div class="container post"><p>本来打算在上一篇中就记录引用类型这一章节，可是在记录过程中发现完全可以把这一部分单独为一篇博客。JS的引用类型看上去有些像java的类，但不是相同的概念，面向对象的类有多重要，我觉得可以类比到JS</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起，通常被称为类。</p>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>目前看到的大多数的引用类型都是Object类型的实例。创建Object实例的方式有两种：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()； <span class="comment">//使用new操作符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;; <span class="comment">//使用对象字面量语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;   <span class="comment">//也是使用对象字面量语法</span></span><br><span class="line">    name : <span class="string">"xxxx"</span>， <span class="comment">// name 可以写成 "name"</span></span><br><span class="line">    age : <span class="number">22</span>        <span class="comment">//不加逗号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象字面量语法更加受开发人员青睐，代码少，封装感，而且对象字面量也是向函数传递大量可选参数的首选方式。例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testFunction(&#123;</span><br><span class="line">    name : <span class="string">"xxx"</span>,</span><br><span class="line">    age : <span class="number">23</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>一般来说，对象访问属性时使用点表示法，JS也可以使用方括号表示法来访问对象的属性，功能上来看，这两种方法没有任何区别，但是使用方括号的主要优点在于，可以通过变量来访问属性。对于可能造成语法错误的的字符或关键字和保留字，可以使用方括号的方式解决。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="string">"xxx"</span>;</span><br><span class="line">person[key]; <span class="comment">//通过变量访问属性</span></span><br><span class="line"></span><br><span class="line">person[<span class="string">"xxx xxx"</span>]; <span class="comment">//带有空格的对象属性，使用方括号获取。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><p>创建Array对象也有两种方式，第一种是使用Array构造函数，示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors =  <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> colors =  <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> colors =  <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"grey"</span>);</span><br><span class="line"><span class="keyword">var</span> colors =  <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"grey"</span>); <span class="comment">//省略new</span></span><br></pre></td></tr></table></figure></p>
<p>第二种基本方式是使用数组字面量表示法：示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors =  [] <span class="comment">//空数组</span></span><br><span class="line"><span class="keyword">var</span> colors =  [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"grey"</span>];</span><br></pre></td></tr></table></figure></p>
<p>数组的length属性很有特点，它不是只读的，可以通过设置这个属性，从数组的末尾移除项或者向数组添加新项。利用length属性方便在末尾添加新项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors =  [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"grey"</span>];</span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">colors[colors.length] = <span class="string">"white"</span>;</span><br><span class="line">colors[colors.length] = <span class="string">"blue"</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><p>对于一个数组或者一个全局作用域而言，使用instanceof操作就能得到满意的结果，但如果又多个全局作用域的话可能存在不同的Array构造函数。<br>所有ECMAScript提供的Array.isArray()方法。用来判断引用对象是不是数组。</p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"blue"</span>); <span class="comment">//count = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop()</span><br></pre></td></tr></table></figure>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"blue"</span>); <span class="comment">//count = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.shift()</span><br></pre></td></tr></table></figure>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><p>数组已经又两个直接用来重排序的方法：reverse（）和sort（）。<br>reverse（）方法会反转数组项的顺序。<br>sort（）默认为升序排序，而且比较的都是字符串，即使是数字也会调用toString（）方法后进行字符串的比较。<br>但这种方法在多数情况下不是最佳方案，所以sort（）函数可以接收一个比较函数作为参数。</p>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p>数组的concat（）方法基于现在的数组创建一个新的数组，是原来数组的一个副本，有独立的内存空间，其参数是要在新的数组中添加的项，参数可以是一个项或者是一个数组，concat（）方法都会把这些一一加入到副本数组中。<br>数组的slice（）方法是基于现在数组分割出一个子数组，子数组有独立的内存空间。可以有一个或两个参数，一个参数的情况下，返回从该项到结尾的所有项，如果是两个参数，则返回起始项到结束位置的前一项，不包括结束位置的项。因为是独立的新的内存空间，所有slice（）不会影响原数组内容。<br>数组的pslice（）方法是个功能很强大的方法。具体包括：<br>删除：指定2个参数：1、要删除的第一项的位置； 2、要删除的项数。<br>插入：指定3+个参数：1、其实位置； 2、0（因为是插入所以要删除的项数设为0）； 3、要插入的项。<br>替换：指定3+个参数：1、其实位置； 2、要删除的项数； 3、要插入的项。</p>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><p>数组实例包含两个位置方法 indexOf（）和lastIndexOf（），这两个方法都接收两个参数，1、要查找的项，2、（可选）查找起点位置的索引。其中indexOf（）是从index小到大搜索，lastIndexOf（）是从大到小搜索。</p>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>迭代方法包括every（），filter（）， forEach（），map（），some（），每个方法接收两个参数：1、每一项上运行的函数，2、（可选）该函数的作用域。传入的函数会接收三个参数：1、数组项的值， 2、该项在数组中的位置， 3、数组对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><p>new Date（）获取当前时间。</p>
<h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3><p>ECMAScript通过RegExp类型来支持正则表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags;</span><br></pre></td></tr></table></figure></p>
<p>pattern部分是正则表达式，每个正则表达式都可带一个或多个flags，支持的flags有：<br>g：全局模式，匹配到第一个后会继续匹配；<br>i：不区分大小写；<br>m：多行模式，一行匹配不到，会在下一行继续匹配。</p>
<h4 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h4><p>global：boolen，是否设置g flag。<br>ignoreCase：boolen， 是否设置i flag<br>lastIndex： int， 搜索下一个匹配项的字符位置<br>multiline： boolen， 是否设置m flag<br>source：string， 返回正则表达式的字符串</p>
<h4 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h4><p>RegExp对象的主要方法是exec（），接收一个参数即要使用pattern的字符串。返回包含第一个匹配项信息的数组，没有匹配项返回null。如果加了g标签，每次执行exec（）都会匹配字符串中的下一个匹配项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = pattern.exec(str);</span><br></pre></td></tr></table></figure></p>
<h4 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h4><p>input（$_）:最近一次要匹配的字符串<br>lastMatch（$&amp;）:最近一次匹配项<br>lastParen（$+）：最近一次匹配的捕获组<br>leftContex（$`）：input字符串中lastMatch之前的文本<br>multiline（$*）：boolen，是否所有表达式都使用多行模式<br>rightContext（$’）：input字符串中lastMatch之后的文本</p>
<h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><p>ECMAScript中的函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。函数名实际是一个指向函数对象的指针，不会与某个函数绑定。</p>
<h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span> (<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx = <span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;; <span class="comment">//有分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用构造函数定义函数， 不推荐，会导致两次解析代码</span></span><br><span class="line"><span class="keyword">var</span> xxx = <span class="keyword">new</span> <span class="built_in">Function</span> (<span class="string">".."</span>, <span class="string">".."</span>, <span class="string">"return .."</span>);</span><br></pre></td></tr></table></figure>
<p>JS函数没有重载，1、参数是数组，2、函数名是引用，函数名相同时候，后执行的会覆盖之前执行的内容。</p>
<h4 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h4><p>解释器在向执行环境中加载数据时，对函数的声明和函数表达式并非一视同仁，解释器会先度曲函数声明，并使其在执行任何代码前可用，函数表达式要等到解释器执行到他所在的代码行时才会被解释执行。<br>在代码执行之前，解析器就已经通过一个名为函数声明提升的过程，将声明添加到执行环境中，js引擎第一遍会声明函数并把他们放在源代码顶部。</p>
<p>函数内部有两个特殊对象，arguments和this，arguments有一个叫做callee的属性，该属性是个指针，指向拥有该arguments对象的函数。<br>this和java中的this类似，this引用的是函数据以执行的环境对象。<br>caller对象保存这调用当前函数的函数引用。（arguments.callee.caller可以实现低耦合）</p>
<h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4><p>函数本身是对象，所以函数有属性和方法，每个函数都包含length和prototype两个属性，length表示函数希望接收到的参数的个数。<br>prototype是保存引用类型所有实例方法的真正所在，例如toString（）、valueOf（）等方法都保存在prototype名下。prototype属性不可以枚举。<br>每个函数都包含两个非继承而来的方法，apply（）和call（），作用都是在特定的作用域中调用函数，apply有两个参数一个是要在其内运行的作用域，一个是参数，可以是arguments对象或者数组，call与apply类似，但所call的参数需要都列出来。使用call和apply扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。</p>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>转载请注明: <a href="http://jhyan.me/2017/12/11/JS高级程序设计---笔记（3）/" target="_blank" rel="noopener">http://jhyan.me/2017/12/11/JS高级程序设计---笔记（3）/</a></p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:yanjunhan@163.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/junhyan" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">woodenbox</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>