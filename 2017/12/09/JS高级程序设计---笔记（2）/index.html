<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JS高级程序设计---笔记（2） | 这就是个木匣子</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">这就是个木匣子</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">首页</a><a href="/archives" class="sidebar-nav-item">归档</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>JS高级程序设计---笔记（2）</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2017-12-09</div></div></div><article><div class="container post"><p>前面一篇已经记录到了第三章，本篇从第四章开始记录，阅读第四章：变量、作用域和内存问题</p>
<h2 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h2><h3 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h3><p>undefined、null、boolen、number和string是基本数据类型，是按值访问的。可以操作保存在变量里的实际值。<br>引用类型是保存在内存中的对象。</p>
<h4 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h4><p>可以为引用类型的值动态添加、改变和删除属性和方法。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'me'</span>; <span class="comment">//person.name has the real value.</span></span><br></pre></td></tr></table></figure></p>
<p>但是对于基本类型，不能动态的为其添加属性，尽管不胡导致错误但是添加的属性回事undefined。</p>
<h4 id="复制变量"><a href="#复制变量" class="headerlink" title="复制变量"></a>复制变量</h4><p>除了保存方式不一样之外，基本类型和引用类型在进行变量复制的时候也存在不同。<br>基本类型的变量在复制的时候会单独分配内存作为原来变量值的副本，在操作过程中两个变量互不影响。<br>当一个变量向另一个变量复制引用类型的值时，复制的是一个对象的指针，而且指针指向的内存与原来引用变量所指向的内存相同。</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>JS中所有的参数都是按值传递的，把函数外部的值复制给函数内部，基本类型的值的传递与基本类型变量复制一样，引用类型的值传递与引用类型的变量复制一样。传递基本类型的值时候，会把值复制到一个局部变量，传递引用变量时候，会把值在内存的地址（即指针）复制给一个局部变量。</p>
<h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><p>基本数据类型的值使用typeof，但对于引用类型，typeof只能显示为object，所以需要使用instanceof,语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure></p>
<p>规定所有引用类型都是object，所以在instanceof操作符检测基本类型的值时候，操作符始终返回false，因为基本类型不是对象。</p>
<h3 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h3><p>执行环境定义了变量或函数有权访问其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>在web浏览器中全局执行环境被认为是window对象。所有全局变量和函数都是作为window对象的属性和方法创建的。<br>每个函数都有自己的执行环境。将活动对象作为变量对象，活动对象在最开始只包含一个变量，即arguments对象（在全局环境中不存在，所以可以在函数内通过该对象来进行参数的获取）。</p>
<p>可以通过with和try-catch语句中的catch块来延长作用域链。对于with语句来说，会将指定的对象添加到作用域链中。对于catch语句来说，会创建新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<h4 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h4><p>上两个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(color);  <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(i); <span class="comment">//10</span></span><br></pre></td></tr></table></figure></p>
<p>不会向c语言中if或者for中存在块级作用域，在if或者for运行结束后在内部声明定义的变量会被销毁。在JS中，这些变量不会被销毁。<br>使用var声明的变量会被自动添加到最接近的执行环境中。之前也有提过，如果初始化变量时没有使用var声明，则默认被添加到全局环境。<br>查询标示符按照就进原则。</p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>JS具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。</p>
<h4 id="清除标记"><a href="#清除标记" class="headerlink" title="清除标记"></a>清除标记</h4><p>JS最常用的GC方式就是清除标记（mark-and-sweep），垃圾收集器在运行的时候会给内存中的变量都加上标记，然后去掉当前在环境中运行的变量和被变量应用的变量的标记，没有去掉标记的被视为应该删除的变量内存。垃圾收集器对含有标记的内存部分进行清除操作。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>一种不太常用的GC策略叫做引用计数，引用类型的内存在赋值给一个变量时候，记录引用次数为+1，当该部分内存的引用变量又指向了其他的内存的时候，该部分内存引用次数-1，当引用次数为0的时候在垃圾收集器运行的时候，会将其清除。</p>
<h4 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h4><p>系统为了防止JS网页耗尽全部内存而导致系统崩溃，分配给浏览器的内存数量通常要比应用程序少。为了用最少的内存可以让页面获得更好的性能，内存占用优化的最佳方式就是执行的代码中只保存 必要的数据，一旦数据不再有用，最好通过将其值设为null来释放其引用，这个做法叫做—解除引用。这种做法适合大部分全局变量和全局对象属性。<br>解除一个值的引用并不意味着自动回收该值所占用的内存，真正的作用是让值脱离执行环境，在垃圾收集器下次运行时候对其进行回收。</p>
<p>转载请注明: <a href="http://jhyan.me/2017/12/09/JS高级程序设计---笔记（2）/" target="_blank" rel="noopener">http://jhyan.me/2017/12/09/JS高级程序设计---笔记（2）/</a></p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:yanjunhan@163.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/junhyan" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">woodenbox</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>