<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>网卡驱动（ixgbe为例） | 这就是个木匣子</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">这就是个木匣子</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">首页</a><a href="/archives" class="sidebar-nav-item">归档</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>网卡驱动（ixgbe为例）</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2017-10-24</div></div></div><article><div class="container post"><p>之前一直在做solaris操作系统的网卡驱动，从oracle放弃这个操作系统后就与网卡驱动接触的越来越少了，最近看了下linux的网卡驱动，总结一波。</p>
<h3 id="驱动加载起源Probe"><a href="#驱动加载起源Probe" class="headerlink" title="驱动加载起源Probe"></a>驱动加载起源Probe</h3><p>废话不多说，上代码。在代码中添加了很多的注释，但比较乱，可以直接跳过往下看。</p>
<p><font color="red">注：代码块看不到的可以点击代码块按键盘左右键阅读</font><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ixgbe_probe - Device Initialization Routine</span></span><br><span class="line"><span class="comment"> * @pdev: PCI device information struct //代表pci ixgbe网卡设备</span></span><br><span class="line"><span class="comment"> * @ent: entry in ixgbe_pci_tbl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, negative on failure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ixgbe_probe initializes an adapter identified by a pci_dev structure.</span></span><br><span class="line"><span class="comment"> * The OS initialization, configuring of the adapter private structure,</span></span><br><span class="line"><span class="comment"> * and a hardware reset occur.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="comment">//pci_dev结构是在启动阶段保留下来的代表了网卡设备，体现了作为PCI设备所应有的规范。</span></span><br><span class="line"> <span class="comment">//net_device结构，为上层协议提供统一的接口，是驱动层的网卡操作结构,网卡的网络传输性质，实际是通过另一结构体net_device来体现的，该结构体的初始化由网卡驱动程序实现</span></span><br><span class="line"> <span class="comment">//PCI设备的驱动程序由pci_driver结构体表示，故网卡驱动应该是该结构体的一个实例</span></span><br><span class="line"> <span class="comment">//网卡驱动实际操作的特定适配器是由与硬件相关的adapter所表示的结构体，adapter体现了大部分与硬件相关的属性</span></span><br><span class="line"> <span class="comment">//与网卡设备pci_dev的通信是通过adapter来实现的，而这个实现则是网卡驱动所要完成的任务</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *ip</span></span><br><span class="line"><span class="comment">  *net_device</span></span><br><span class="line"><span class="comment">  *adapter adapter-hw从pci dev中读出的硬件参数</span></span><br><span class="line"><span class="comment">  *pci_dev</span></span><br><span class="line"><span class="comment">  *pci</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ixgbe_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span>;</span> <span class="comment">//point to the net_device struct, but after that is the ixgbe private data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_adapter</span> *<span class="title">adapter</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_hw</span> *<span class="title">hw</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ixgbe_info</span> *<span class="title">ii</span> = <span class="title">ixgbe_info_tbl</span>[<span class="title">ent</span>-&gt;<span class="title">driver_data</span>];</span><span class="comment">//通过硬件的信息来确定需要初始化那个驱动,针对不同设</span></span><br><span class="line">备调用不同的操作</span><br><span class="line">    <span class="keyword">int</span> i, err, pci_using_dac, expected_gts;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices = MAX_TX_QUEUES;<span class="comment">//64</span></span><br><span class="line">    u8 part_str[IXGBE_PBANUM_LENGTH];</span><br><span class="line">    <span class="keyword">bool</span> disable_dev = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IXGBE_FCOE</span></span><br><span class="line">    u16 device_caps;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    u32 eec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Catch broken hardware that put the wrong VF device ID in</span></span><br><span class="line"><span class="comment">     * the PCIe SR-IOV capability.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;is_virtfn) &#123;</span><br><span class="line">        WARN(<span class="number">1</span>, KERN_ERR <span class="string">"%s (%hx:%hx) should not be a VF!\n"</span>,</span><br><span class="line">             pci_name(pdev), pdev-&gt;vendor, pdev-&gt;device);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//PCI设备中一般都带有一些RAM和ROM 空间，通常的控制/状态寄存器和数据寄存器也往往以RAM区间的形式出现，而这些区间的地址在</span></span><br><span class="line">设备内部一般都是从<span class="number">0</span>开始编址的，那么当总线上挂接了多个设备时，对这些空间的访问就会产生冲突。所以，这些地址都要先映射到&gt;系统总线上，再进一步映射到内核的虚拟地址空间。</span><br><span class="line">    err = pci_enable_device_mem(pdev);<span class="comment">//Initialize device before it's used by a driver. Ask low-level code to enable Memory resources</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dma_set_mask_and_coherent(&amp;pdev-&gt;dev, DMA_BIT_MASK(<span class="number">64</span>))) &#123;<span class="comment">//check the dma mask is logical 64</span></span><br><span class="line">        pci_using_dac = <span class="number">1</span>; ：<span class="comment">//DAC是一种将数字信号转换为模拟信号（以电流、电压或电荷的形式）的设备,is this mean support in 64 bit sys???</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = dma_set_mask_and_coherent(&amp;pdev-&gt;dev, DMA_BIT_MASK(<span class="number">32</span>));</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            dev_err(&amp;pdev-&gt;dev,</span><br><span class="line">                <span class="string">"No usable DMA configuration, aborting\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> err_dma;</span><br><span class="line">        &#125;</span><br><span class="line">        pci_using_dac = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//几乎每一种外设都是通过读写设备上的寄存器来进行的，通常包括控制寄存器、状态寄存器和数据寄存器三大类，外设的寄存器</span></span><br><span class="line">通常被连续地编址</span><br><span class="line">    err = pci_request_mem_regions(pdev, ixgbe_driver_name);<span class="comment">//alloc phy mem to dev通知内核该设备对应的IO端口和内存资源&gt;已经使用，其他的PCI设备不要再使用这个区域</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev,</span><br><span class="line">            <span class="string">"pci_request_selected_regions failed 0x%x\n"</span>, e<span class="comment">//register the netdev to the system, via rtnetlinkrr);</span></span><br><span class="line">        <span class="keyword">goto</span> err_pci_reg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pci_enable_pcie_error_reporting(pdev);</span><br><span class="line"></span><br><span class="line">    pci_set_master(pdev);<span class="comment">//enables bus-mastering for device dev</span></span><br><span class="line">    pci_save_state(pdev);<span class="comment">//save the PCI configuration space of a device before suspending而PCI配置空间由Linux内核中的PCI初始化代码使用，这些代码用于配置PCI设备，比如中断号以及I/O或内存基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ii-&gt;mac == ixgbe_mac_82598EB) &#123;</span><br><span class="line">#ifdef CONFIG_IXGBE_DCB</span><br><span class="line">        <span class="comment">/* 8 TC w/ 4 queues per TC */</span></span><br><span class="line">        indices = <span class="number">4</span> * MAX_TRAFFIC_CLASS;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">        indices = IXGBE_MAX_RSS_INDICES;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Allocates a struct net_device with private data area for driver use and performs basic initialization.  Also allocates subqueue structs for each queue on the device.</span></span><br><span class="line"></span><br><span class="line">    netdev = alloc_etherdev_mq(<span class="keyword">sizeof</span>(struct ixgbe_adapter), indices);<span class="comment">// indices max tx queue 64 defined local, alloc_netdev_mqs, the alloc size is net_device plus ixgbe_adapter</span></span><br><span class="line">    <span class="keyword">if</span> (!netdev) &#123;</span><br><span class="line">        err = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_etherdev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);<span class="comment">//(netdev)-&gt;dev.parent = (pdev) the device to which it is attached</span></span><br><span class="line"></span><br><span class="line">    adapter = netdev_priv(netdev); <span class="comment">//point to the end of net_device struct, access network device private data</span></span><br><span class="line"></span><br><span class="line">    adapter-&gt;netdev = netdev;</span><br><span class="line">    adapter-&gt;pdev = pdev; <span class="comment">//pci dev</span></span><br><span class="line">    hw = &amp;adapter-&gt;hw;<span class="comment">//hw assign</span></span><br><span class="line">    hw-&gt;back = adapter;</span><br><span class="line">    adapter-&gt;msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);</span><br><span class="line"></span><br><span class="line">    hw-&gt;hw_addr = ioremap(pci_resource_start(pdev, <span class="number">0</span>),</span><br><span class="line">                  pci_resource_len(pdev, <span class="number">0</span>));<span class="comment">//map dev physical address to the virtrul mem addr to make the driver can be operated.</span></span><br><span class="line">    adapter-&gt;io_addr = hw-&gt;hw_addr;</span><br><span class="line">    <span class="keyword">if</span> (!hw-&gt;hw_addr) &#123;</span><br><span class="line">        err = -EIO;</span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    netdev-&gt;netdev_ops = &amp;ixgbe_netdev_ops;<span class="comment">//ixgbe operatation .open .close .start_xmit</span></span><br><span class="line">    ixgbe_set_ethtool_ops(netdev); <span class="comment">//netdev-&gt;ethtool_ops callback &amp;ixgbe_ethtool_ops;</span></span><br><span class="line">    netdev-&gt;watchdog_timeo = <span class="number">5</span> * HZ;</span><br><span class="line">    strlcpy(netdev-&gt;name, pci_name(pdev), <span class="keyword">sizeof</span>(netdev-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup hw api */</span></span><br><span class="line">    hw-&gt;mac.ops   = *ii-&gt;mac_ops;</span><br><span class="line">    hw-&gt;mac.type  = ii-&gt;mac;</span><br><span class="line">    hw-&gt;mvals     = ii-&gt;mvals;</span><br><span class="line">    <span class="keyword">if</span> (ii-&gt;link_ops)</span><br><span class="line">        hw-&gt;link.ops  = *ii-&gt;link_ops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EEPROM */</span></span><br><span class="line">    hw-&gt;eeprom.ops = *ii-&gt;eeprom_ops;</span><br><span class="line">    eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw)); <span class="comment">//EEC EEPROM/Flash Control Register</span></span><br><span class="line">    <span class="keyword">if</span> (ixgbe_removed(hw-&gt;hw_addr)) &#123; <span class="comment">//maped by ioremap</span></span><br><span class="line">        err = -EIO;</span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If EEPROM is valid (bit 8 = 1), use default otherwise use bit bang */</span></span><br><span class="line">    <span class="keyword">if</span> (!(eec &amp; BIT(<span class="number">8</span>)))</span><br><span class="line">        hw-&gt;eeprom.ops.read = &amp;ixgbe_read_eeprom_bit_bang_generic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup the private structure */</span></span><br><span class="line">    err = ixgbe_sw_init(adapter, ii);<span class="comment">// Initialize general software structures (struct ixgbe_adapter)based on PCI device information</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_sw_init;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the SWFW semaphore is in a valid state */</span></span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;mac.ops.init_swfw_sync)</span><br><span class="line">        hw-&gt;mac.ops.init_swfw_sync(hw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make it possible the adapter to be woken up via WOL */</span> <span class="comment">//wake on lan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Resets the hardware by resetting the transmit and receive units, masks</span></span><br><span class="line"><span class="comment"> *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)</span></span><br><span class="line"><span class="comment"> *  reset.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">    err = hw-&gt;mac.ops.reset_hw(hw);<span class="comment">//ixgbe_reset_hw_82599, init hw include tx rx units and mac, link</span></span><br><span class="line">    hw-&gt;phy.reset_if_overtemp = <span class="literal">false</span>;</span><br><span class="line">    ixgbe_set_eee_capable(adapter);</span><br><span class="line">    <span class="keyword">if</span> (err == IXGBE_ERR_SFP_NOT_PRESENT) &#123;<span class="comment">//sfp Small Form-factor Pluggable 电信号转换为光信号的接口器件</span></span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == IXGBE_ERR_SFP_NOT_SUPPORTED) &#123;</span><br><span class="line">        e_dev_err(<span class="string">"failed to load because an unsupported SFP+ or QSFP module type was detected.\n"</span>);</span><br><span class="line">        e_dev_err(<span class="string">"Reload the driver after installing a supported module.\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_sw_init;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        e_dev_err(<span class="string">"HW Init failed: %d\n"</span>, err);</span><br><span class="line">        <span class="keyword">goto</span> err_sw_init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PCI_IOV</span><br><span class="line">    <span class="comment">/* SR-IOV not supported on the 82598 */</span></span><br><span class="line">    <span class="keyword">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)</span><br><span class="line">        <span class="keyword">goto</span> skip_sriov;</span><br><span class="line">    <span class="comment">/* Mailbox */</span></span><br><span class="line">    ixgbe_init_mbx_params_pf(hw); <span class="comment">//Initializes the hw-&gt;mbx struct to correct values for pf mailbox</span></span><br><span class="line">    hw-&gt;mbx.ops = ii-&gt;mbx_ops;<span class="comment">//mbx operation based on the mac type</span></span><br><span class="line">    pci_sriov_set_totalvfs(pdev, IXGBE_MAX_VFS_DRV_LIMIT);<span class="comment">//dev-&gt;sriov-&gt;driver_max_VFs = numvfs;63</span></span><br><span class="line">    ixgbe_enable_sriov(adapter, max_vfs);<span class="comment">//max_vfs??? 0</span></span><br><span class="line">skip_sriov:</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">    <span class="comment">/* make sure the EEPROM is good */</span> <span class="comment">//Electrically Erasable Programmable read only memory</span></span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;eeprom.ops.validate_checksum(hw, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        e_dev_err(<span class="string">"The EEPROM Checksum Is Not Valid\n"</span>);</span><br><span class="line">        err = -EIO;</span><br><span class="line">        <span class="keyword">goto</span> err_sw_init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eth_platform_get_mac_address(&amp;adapter-&gt;pdev-&gt;dev,</span><br><span class="line">                     adapter-&gt;hw.mac.perm_addr);<span class="comment">//copy pdev info macaddr to the adapter hw initial value of the ports MAC address.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(netdev-&gt;dev_addr, hw-&gt;mac.perm_addr, netdev-&gt;addr_len);<span class="comment">//copy the hw mac addr to the net_device dev_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_valid_ether_addr(netdev-&gt;dev_addr)) &#123; <span class="comment">// validate the dev addr</span></span><br><span class="line">        e_dev_err(<span class="string">"invalid MAC address\n"</span>);</span><br><span class="line">        err = -EIO;</span><br><span class="line">        <span class="keyword">goto</span> err_sw_init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set hw-&gt;mac.addr to permanent MAC address */</span></span><br><span class="line">    ether_addr_copy(hw-&gt;mac.addr, hw-&gt;mac.perm_addr);<span class="comment">//copy the init mac addr to the current mac addr</span></span><br><span class="line">    ixgbe_mac_set_default_filter(adapter);<span class="comment">//write hw mac addr to the rar as the default mac filter</span></span><br><span class="line"></span><br><span class="line">    timer_setup(&amp;adapter-&gt;service_timer, ixgbe_service_timer, <span class="number">0</span>);<span class="comment">//setup timer, service_timer-&gt;function =ixgbe_service_timer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ixgbe_removed(hw-&gt;hw_addr)) &#123;</span><br><span class="line">        err = -EIO;</span><br><span class="line">        <span class="keyword">goto</span> err_sw_init;</span><br><span class="line">    &#125;</span><br><span class="line">    INIT_WORK(&amp;adapter-&gt;service_task, ixgbe_service_task);<span class="comment">//init work service_task-&gt;fun=ixgbe_service_task ???work</span></span><br><span class="line">    set_bit(__IXGBE_SERVICE_INITED, &amp;adapter-&gt;state);</span><br><span class="line">    clear_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state);</span><br><span class="line"></span><br><span class="line">    err = ixgbe_init_interrupt_scheme(adapter);<span class="comment">//interrupt vectors init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_sw_init;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_rx_queues; i++) <span class="comment">//init ring-&gt;syncp</span></span><br><span class="line">        u64_stats_init(&amp;adapter-&gt;rx_ring[i]-&gt;syncp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_tx_queues; i++)</span><br><span class="line">        u64_stats_init(&amp;adapter-&gt;tx_ring[i]-&gt;syncp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_xdp_queues; i++)</span><br><span class="line">        u64_stats_init(&amp;adapter-&gt;xdp_ring[i]-&gt;syncp);</span><br><span class="line">    <span class="comment">/* WOL not supported for all devices */</span></span><br><span class="line">    adapter-&gt;wol = <span class="number">0</span>;</span><br><span class="line">    hw-&gt;eeprom.ops.read(hw, <span class="number">0x2c</span>, &amp;adapter-&gt;eeprom_cap);</span><br><span class="line">    hw-&gt;wol_enabled = ixgbe_wol_supported(adapter, pdev-&gt;device, <span class="comment">//wake on lan</span></span><br><span class="line">                        pdev-&gt;subsystem_device);</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;wol_enabled)</span><br><span class="line">        adapter-&gt;wol = IXGBE_WUFC_MAG;</span><br><span class="line"></span><br><span class="line">    device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* save off EEPROM version number */</span></span><br><span class="line">    hw-&gt;eeprom.ops.read(hw, <span class="number">0x2e</span>, &amp;adapter-&gt;eeprom_verh);</span><br><span class="line">    hw-&gt;eeprom.ops.read(hw, <span class="number">0x2d</span>, &amp;adapter-&gt;eeprom_verl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pick up the PCI bus settings for reporting later */</span></span><br><span class="line">    <span class="keyword">if</span> (ixgbe_pcie_from_parent(hw))</span><br><span class="line">        ixgbe_get_parent_bus_info(adapter); <span class="comment">//get information from pci bus</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         hw-&gt;mac.ops.get_bus_info(hw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate the expected PCIe bandwidth required for optimal</span></span><br><span class="line"><span class="comment">     * performance. Note that some older parts will never have enough</span></span><br><span class="line"><span class="comment">     * bandwidth due to being older generation PCIe parts. We clamp these</span></span><br><span class="line"><span class="comment">     * parts to ensure no warning is displayed if it can't be fixed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span> (hw-&gt;mac.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ixgbe_mac_82598EB:</span><br><span class="line">        expected_gts = min(ixgbe_enumerate_functions(adapter) * <span class="number">10</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        expected_gts = ixgbe_enumerate_functions(adapter) * <span class="number">10</span>; <span class="comment">//ixgbe_enumerate_functions get the port numbers of the dev</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* don't check link if we failed to enumerate functions */</span></span><br><span class="line">    <span class="keyword">if</span> (expected_gts &gt; <span class="number">0</span>)</span><br><span class="line">        ixgbe_check_minimum_link(adapter, expected_gts);</span><br><span class="line"></span><br><span class="line">    err = ixgbe_read_pba_string_generic(hw, part_str, <span class="keyword">sizeof</span>(part_str));</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        strlcpy(part_str, <span class="string">"Unknown"</span>, <span class="keyword">sizeof</span>(part_str));</span><br><span class="line">    <span class="keyword">if</span> (ixgbe_is_sfp(hw) &amp;&amp; hw-&gt;phy.sfp_type != ixgbe_sfp_type_not_present)                                           </span><br><span class="line">        e_dev_info(<span class="string">"MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n"</span>,</span><br><span class="line">               hw-&gt;mac.type, hw-&gt;phy.type, hw-&gt;phy.sfp_type,</span><br><span class="line">               part_str);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        e_dev_info(<span class="string">"MAC: %d, PHY: %d, PBA No: %s\n"</span>,</span><br><span class="line">               hw-&gt;mac.type, hw-&gt;phy.type, part_str);</span><br><span class="line"></span><br><span class="line">    e_dev_info(<span class="string">"%pM\n"</span>, netdev-&gt;dev_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the hardware with the new settings */</span></span><br><span class="line">    err = hw-&gt;mac.ops.start_hw(hw);</span><br><span class="line">    <span class="keyword">if</span> (err == IXGBE_ERR_EEPROM_VERSION) &#123;</span><br><span class="line">        <span class="comment">/* We are running on a pre-production device, log a warning */</span></span><br><span class="line">        e_dev_warn(<span class="string">"This device is a pre-production adapter/LOM. "</span></span><br><span class="line">               <span class="string">"Please be aware there may be issues associated "</span></span><br><span class="line">               <span class="string">"with your hardware.  If you are experiencing "</span></span><br><span class="line">               <span class="string">"problems please contact your Intel or hardware "</span></span><br><span class="line">               <span class="string">"representative who provided you with this "</span></span><br><span class="line">               <span class="string">"hardware.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(netdev-&gt;name, <span class="string">"eth%d"</span>);</span><br><span class="line">    pci_set_drvdata(pdev, adapter);<span class="comment">//set pdev-&gt;driver=adapter</span></span><br><span class="line">    err = register_netdev(netdev);<span class="comment">//register the netdev to the system, via rtnetlink</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_register;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* power down the optics for 82599 SFP+ fiber */</span></span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;mac.ops.disable_tx_laser)</span><br><span class="line">        hw-&gt;mac.ops.disable_tx_laser(hw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span></span><br><span class="line">    netif_carrier_off(netdev);<span class="comment">// 当设备驱动侦测到在其设备上丢失信号时，它调用netif_carrier_off函数</span></span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_IXGBE_DCA</span><br><span class="line">    <span class="keyword">if</span> (dca_add_requester(&amp;pdev-&gt;dev) == <span class="number">0</span>) &#123;</span><br><span class="line">        adapter-&gt;flags |= IXGBE_FLAG_DCA_ENABLED;</span><br><span class="line">        ixgbe_setup_dca(adapter); <span class="comment">//direct cache access</span></span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) &#123; <span class="comment">//IXGBE_FLAG_SRIOV_ENABLED is set at ixgbe_enble_sriov</span></span><br><span class="line">        e_info(probe, <span class="string">"IOV is enabled with %d VFs\n"</span>, adapter-&gt;num_vfs);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adapter-&gt;num_vfs; i++) <span class="comment">//config vf mac address</span></span><br><span class="line">            ixgbe_vf_configuration(pdev, (i | <span class="number">0x10000000</span>));</span><br><span class="line">    <span class="comment">/* firmware requires driver version to be 0xFFFFFFFF</span></span><br><span class="line"><span class="comment">     * since os does not support feature</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;mac.ops.set_fw_drv_ver)</span><br><span class="line">        hw-&gt;mac.ops.set_fw_drv_ver(hw, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">                       <span class="keyword">sizeof</span>(ixgbe_driver_version) - <span class="number">1</span>,</span><br><span class="line">                       ixgbe_driver_version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add san mac addr to netdev */</span></span><br><span class="line">    ixgbe_add_sanmac_netdev(netdev); <span class="comment">//add Storage Area Networks mac addr</span></span><br><span class="line"></span><br><span class="line">    e_dev_info(<span class="string">"%s\n"</span>, ixgbe_default_device_descr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加了很多注释在这个函数中，这已经是精简过很多的代码,但还是太杂乱。针对一些关键的部分进行详细的跟踪。<br>主要包括netdev分配函数alloc_etherdev_mq，adapter获取函数netdev_priv，ixgbe软件结构体ixgbe_adapter的初始化函数ixgbe_sw_init，mac地址的获取和添加和mac filter可以看上面代码中的注释，还有就是网卡的中断注册函数ixgbe_init_interrupt_scheme。这些都会在后续部分进行介绍。</p>
<h3 id="netdev分配"><a href="#netdev分配" class="headerlink" title="netdev分配"></a>netdev分配</h3><p>pcidev，netdev，adapter的关系我个人的观点就试pcidev可以理解为就是pci插槽上的物理网卡，netdev是上层协议所识别的网络设备，adapter就是驱动，把pcidev转变成大家认识的netdev并且把数据处理后传递给上层或发送出去。<br>alloc_netdev_mqs会分配一个sizeof（netdev）+sizeof（ixgbe_adapter）大小的空间，并且在空间里做一些初始化的操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct net_device *<span class="title">alloc_netdev_mqs</span><span class="params">(<span class="keyword">int</span> sizeof_priv, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">char</span> name_assign_type,</span></span></span><br><span class="line">        void (*setup)(struct net_device *),</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> txqs, <span class="keyword">unsigned</span> <span class="keyword">int</span> rxqs)</span><br><span class="line">&#123;</span><br><span class="line">    alloc_size = <span class="keyword">sizeof</span>(struct net_device);<span class="comment">//alloc netdev size</span></span><br><span class="line">    <span class="keyword">if</span>（...）</span><br><span class="line">        alloc_size += sizeof_priv;<span class="comment">//add net_device and ixgbe_adapter  private data</span></span><br><span class="line">    p = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL); <span class="comment">// struct net_device+struct adapter</span></span><br><span class="line">    dev_mc_init(dev);<span class="comment">//Init multicast address list the list is only it's self</span></span><br><span class="line">    dev_uc_init(dev);<span class="comment">//Init unicast address list</span></span><br><span class="line">    setup(dev);<span class="comment">//callback ether_setup init netdev,dev-&gt;header_ops = &amp;eth_header_ops;</span></span><br><span class="line">    <span class="keyword">if</span> (netif_alloc_netdev_queues(dev))<span class="comment">//alloc tx queues</span></span><br><span class="line">    <span class="keyword">if</span> (netif_alloc_rx_queues(dev))<span class="comment">//alloc rx queues</span></span><br><span class="line">    dev-&gt;group = INIT_NETDEV_GROUP; <span class="comment">//Initial net device group. All devices belong to group 0 by default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="adapter的获取"><a href="#adapter的获取" class="headerlink" title="adapter的获取"></a>adapter的获取</h3><p>adapter的获取可以说是一个小技巧，但是在linux中却特别常用。具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">netdev_priv</span><span class="params">(<span class="keyword">const</span> struct net_device *dev)</span>                                                         </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//point to the end of net_device struct, access network device private data</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)dev + ALIGN(<span class="keyword">sizeof</span>(struct net_device), NETDEV_ALIGN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释我加上去的英语水平也有限，大家凑和理解。因为在分配netdev的时候已经分配了adapter大小的空间，所以这个时候只要把指针指到该位置即可。</p>
<h3 id="adapter初始化"><a href="#adapter初始化" class="headerlink" title="adapter初始化"></a>adapter初始化</h3><p>驱动的初始化主要在ixgbe_sw_init函数中，该函数根据pci信息对ixgbe驱动进行初始化操作。因为代码也较长，所以对代码做一些精简，但是一定要有个概念，驱动中的每一行代码都有其重要的作用，具体代码及其我加的注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ixgbe_sw_init</span><span class="params">(struct ixgbe_adapter *adapter,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct ixgbe_info *ii)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rss = <span class="keyword">min_t</span>(<span class="keyword">int</span>, ixgbe_max_rss_indices(adapter), num_online_cpus());<span class="comment">//get the min one from nic rss and online cpu core for 82599 IXGBE_MAX_RSS_INDICES is 16 </span></span><br><span class="line">    adapter-&gt;ring_feature[RING_F_RSS].limit = rss; <span class="comment">//ring_feature rss, this value will be used to alloc q_vector if the feather used is rss</span></span><br><span class="line">       adapter-&gt;mac_table = kzalloc(<span class="keyword">sizeof</span>(struct ixgbe_mac_addr) * <span class="comment">//alloc mac table</span></span><br><span class="line">                     hw-&gt;mac.num_rar_entries,<span class="comment">//Receive Address register num_rar_entries when assign the value</span></span><br><span class="line">                     GFP_ATOMIC);</span><br></pre></td></tr></table></figure>
<p>在代码中有一些我加的注释，在该函数中还会根据不同硬件类型赋予驱动不同的功能feather，由于太多就不加进来了，有兴趣的可以去研究下linux源码。</p>
<h3 id="中断注册"><a href="#中断注册" class="headerlink" title="中断注册"></a>中断注册</h3><p>在这里介绍较新的msi-x的中断注册。注册函数在probe函数中是ixgbe_init_interrupt_scheme，其具体内容如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ixgbe_init_interrupt_scheme</span><span class="params">(struct ixgbe_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Number of supported queues */</span></span><br><span class="line">    ixgbe_set_num_queues(adapter); <span class="comment">//set rx and tx queue num                                                          </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set interrupt mode */</span></span><br><span class="line">    ixgbe_set_interrupt_capability(adapter); <span class="comment">//if enable msi, get the num of msix vector.and set flag IXGBE_FLAG_MSIX_ENABLED,  else disable some feathers and set vector to 1,</span></span><br><span class="line"></span><br><span class="line">    err = ixgbe_alloc_q_vectors(adapter); <span class="comment">//according to the vector's num alloc interrupt vector to rx and tx ring.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如在代码中注释写的一样，ixgbe_set_num_queues会获得网卡的tx和rx队列的数量。ixgbe_set_interrupt_capability函数会在最开始调用ixgbe_acquire_msix_vectors函数来判断是否支持MSI-X，本文只对MSI-X方式的网卡中断做介绍。<br>ixgbe_acquire_msix_vectors所作的事情就是尽可能的找到满足队列要求的最大的中断向量数，当然也会取决于online cpu的限制，把adapter的中断向量数目设置为合适的向量数与最大向量数中较小的一个，并且为adapter添加MSI-X的feacher。具体的内容大家可以阅读该函数的源码。<br>ixgbe_alloc_q_vectors算一个重头戏，实现把中断向量与收发队列进行配对。列出部分主要代码来进行分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ixgbe_alloc_q_vectors</span><span class="params">(struct ixgbe_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q_vectors = adapter-&gt;num_q_vectors;</span><br><span class="line">    <span class="keyword">int</span> rxr_remaining = adapter-&gt;num_rx_queues;<span class="comment">//rx ring num</span></span><br><span class="line">    <span class="keyword">int</span> txr_remaining = adapter-&gt;num_tx_queues;<span class="comment">//tx ring num</span></span><br><span class="line">    <span class="keyword">int</span> xdp_remaining = adapter-&gt;num_xdp_queues;</span><br><span class="line">    <span class="keyword">int</span> rxr_idx = <span class="number">0</span>, txr_idx = <span class="number">0</span>, xdp_idx = <span class="number">0</span>, v_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only one q_vector if MSI-X is disabled. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))</span><br><span class="line">        q_vectors = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q_vectors &gt;= (rxr_remaining + txr_remaining + xdp_remaining)) &#123; <span class="comment">// if the num of q vector is enaugh,every rx ring alloc a q vector</span></span><br><span class="line">        <span class="keyword">for</span> (; rxr_remaining; v_idx++) &#123;</span><br><span class="line">            err = ixgbe_alloc_q_vector(adapter, q_vectors, v_idx,</span><br><span class="line">                           <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, rxr_idx);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> err_out;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update counts and index */</span></span><br><span class="line">            rxr_remaining--;</span><br><span class="line">            rxr_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; v_idx &lt; q_vectors; v_idx++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_idx);<span class="comment">//tail of the rxr_remaining/(q_vectors - v_idx)</span></span><br><span class="line">        <span class="keyword">int</span> tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_idx);</span><br><span class="line">        <span class="keyword">int</span> xqpv = DIV_ROUND_UP(xdp_remaining, q_vectors - v_idx);</span><br><span class="line"></span><br><span class="line">        err = ixgbe_alloc_q_vector(adapter, q_vectors, v_idx,</span><br><span class="line">                       tqpv, txr_idx,</span><br><span class="line">                       xqpv, xdp_idx,</span><br><span class="line">                       rqpv, rxr_idx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> err_out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update counts and index */</span></span><br><span class="line">        rxr_remaining -= rqpv;</span><br><span class="line">        txr_remaining -= tqpv;</span><br><span class="line">        xdp_remaining -= xqpv;</span><br><span class="line">        rxr_idx++;</span><br><span class="line">        txr_idx++;</span><br><span class="line">        xdp_idx += xqpv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ixgbe_alloc_q_vector函数是具体为收发队列分配中断向量的函数。具体在下文进行分析，但此处有一点需要注意，函数中有两个for循环，但是第一个for循环是在if条件中的，如果有足够的中断向量，则为每个收队列分配单独的中断向量，这样做可以提升网卡处理效率。<br>ixgbe_alloc_q_vector函数会为收发队列分配一个中断向量，一般来说如果中断向量不充足，则一个中断向量对应一个tx队列和一个rx队列，如果中断向量特别少的时候可能会有多个tx和rx队列在同一个向量。<br>为了方便之后的查看先列出ixgbe_alloc_q_vector函数声明和各个参数的意义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ixgbe_alloc_q_vector - Allocate memory for a single interrupt vector</span></span><br><span class="line"><span class="comment"> * @adapter: board private structure to initialize</span></span><br><span class="line"><span class="comment"> * @v_count: q_vectors allocated on adapter, used for ring interleaving</span></span><br><span class="line"><span class="comment"> * @v_idx: index of vector in adapter struct</span></span><br><span class="line"><span class="comment"> * @txr_count: total number of Tx rings to allocate</span></span><br><span class="line"><span class="comment"> * @txr_idx: index of first Tx ring to allocate</span></span><br><span class="line"><span class="comment"> * @xdp_count: total number of XDP rings to allocate</span></span><br><span class="line"><span class="comment"> * @xdp_idx: index of first XDP ring to allocate</span></span><br><span class="line"><span class="comment"> * @rxr_count: total number of Rx rings to allocate</span></span><br><span class="line"><span class="comment"> * @rxr_idx: index of first Rx ring to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We allocate one q_vector.  If allocation fails we return -ENOMEM.</span></span><br><span class="line"><span class="comment">static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,                                                        </span></span><br><span class="line"><span class="comment">                int v_count, int v_idx,</span></span><br><span class="line"><span class="comment">                int txr_count, int txr_idx,</span></span><br><span class="line"><span class="comment">                int xdp_count, int xdp_idx,</span></span><br><span class="line"><span class="comment">                int rxr_count, int rxr_idx)</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></p>
<p>然后对函数进行具体的分析，函数源码很多，此处只列举一个关键代码，有兴趣的同学可以在linux源码中查看：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ixgbe_alloc_q_vector</span><span class="params">(struct ixgbe_adapter *adapter,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> v_count, <span class="keyword">int</span> v_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> txr_count, <span class="keyword">int</span> txr_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> xdp_count, <span class="keyword">int</span> xdp_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> rxr_count, <span class="keyword">int</span> rxr_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ring_count = txr_count + rxr_count + xdp_count;<span class="comment">//current v_idx, ring vctort count</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(struct ixgbe_q_vector) +</span><br><span class="line">           (<span class="keyword">sizeof</span>(struct ixgbe_ring) * ring_count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allocate q_vector and rings */</span></span><br><span class="line">    q_vector = kzalloc_node(size, GFP_KERNEL, node);<span class="comment">//alloc 1 interrupt vector and ring_count ixgbe ring</span></span><br><span class="line">    q_vector-&gt;numa_node = node; <span class="comment">//set the ixgbe q vector numa node</span></span><br><span class="line">    netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, <span class="comment">//add napi to ixgbe and callback function ixgbe_poll</span></span><br><span class="line">               ixgbe_poll, <span class="number">64</span>);</span><br><span class="line">    adapter-&gt;q_vector[v_idx] = q_vector;<span class="comment">//add current q vector to the adapter q vectro array</span></span><br><span class="line">    <span class="comment">/* initialize pointer to rings */</span></span><br><span class="line">    ring = q_vector-&gt;ring;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (txr_count) &#123;</span><br><span class="line">        <span class="comment">/* assign generic ring traits */</span></span><br><span class="line">        ring-&gt;dev = &amp;adapter-&gt;pdev-&gt;dev;</span><br><span class="line">        ring-&gt;netdev = adapter-&gt;netdev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* configure backlink on ring */</span></span><br><span class="line">        ring-&gt;q_vector = q_vector;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update q_vector Tx values */</span></span><br><span class="line">        ixgbe_add_ring(ring, &amp;q_vector-&gt;tx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* apply Tx specific ring traits */</span></span><br><span class="line">        ring-&gt;count = adapter-&gt;tx_ring_count;</span><br><span class="line">        <span class="keyword">if</span> (adapter-&gt;num_rx_pools &gt; <span class="number">1</span>)</span><br><span class="line">            ring-&gt;queue_index =</span><br><span class="line">                txr_idx % adapter-&gt;num_rx_queues_per_pool;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ring-&gt;queue_index = txr_idx;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* assign ring to adapter */</span></span><br><span class="line">        adapter-&gt;tx_ring[txr_idx] = ring;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update count and index */</span></span><br><span class="line">        txr_count--;</span><br><span class="line">        txr_idx += v_count; <span class="comment">//add next to the txr_idx </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* push pointer to next ring */</span></span><br><span class="line">        ring++; <span class="comment">//add length of struct ixgbe_ring</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数分配了sizeof(struct ixgbe_q_vector)和(sizeof(struct ixgbe_ring) * ring_count想加大小的连续内存空间,代码中的node都是numa node，numa是一种隔离cpu的技术，有兴趣具体的大家可以google。netif_napi_add是一个为中断向量注册new api的函数，并且为ixgbe网卡注册了ixgbe_poll回调函数。该部分的具体作用即使功能会在后续的网卡接收原理中进行详细的介绍。代码中只列出了对tx队列的操作，rx和xdp有类似的操作，此处不再赘述，些许差异有兴趣大家可以阅读linux源码。ring-&gt;q_vector = q_vector;实现分配中断向量到队列。</p>
<p>SRIOV及其RDMA部分有时间在之后的博客中进行介绍。</p>
<p>转载请注明: <a href="http://jhyan.me/2017/10/24/网卡驱动（ixgbe为例）/" target="_blank" rel="noopener">http://jhyan.me/2017/10/24/网卡驱动（ixgbe为例）/</a></p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:yanjunhan@163.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/junhyan" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">woodenbox</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>